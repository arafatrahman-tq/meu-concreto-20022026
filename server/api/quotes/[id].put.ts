import { eq } from 'drizzle-orm'
import { quotes, quoteItems } from '../../database/schema'
import { db } from '../../utils/db'
import { quoteUpdateSchema } from '../../utils/schemas'
import { requireCompanyAccess } from '../../utils/session'
import { createNotification } from '../../utils/notifications'

export default defineEventHandler(async (event) => {
  const id = getRouterParam(event, 'id')
  if (!id) throw createError({ statusCode: 400, statusMessage: 'ID required' })

  const quoteId = parseInt(id)

  const existing = await db
    .select({
      companyId: quotes.companyId,
      status: quotes.status,
      customerName: quotes.customerName
    })
    .from(quotes)
    .where(eq(quotes.id, quoteId))
    .get()
  if (!existing)
    throw createError({ statusCode: 404, statusMessage: 'Quote not found' })
  requireCompanyAccess(event, existing.companyId)
  const body = await readBody(event)

  // Validation
  const validation = quoteUpdateSchema.safeParse(body)
  if (!validation.success) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Validation Error',
      data: validation.error.flatten()
    })
  }

  const { items, ...quoteData } = validation.data

  try {
    await db.transaction(async (tx) => {
      // Fetch current quote to get existing values for calculations
      const currentQuote = await tx
        .select()
        .from(quotes)
        .where(eq(quotes.id, quoteId))
        .get()
      if (!currentQuote)
        throw createError({
          statusCode: 404,
          statusMessage: 'Quote not found'
        })

      let subtotal = currentQuote.subtotal
      const discount
        = quoteData.discount !== undefined
          ? quoteData.discount
          : currentQuote.discount

      // If items are being updated, recalculate subtotal
      if (items) {
        // Delete existing items
        await tx.delete(quoteItems).where(eq(quoteItems.quoteId, quoteId))

        // Insert new items and sum subtotal
        subtotal = 0
        const itemsToInsert = items.map((item) => {
          const itemTotal = item.quantity * item.unitPrice
          subtotal += itemTotal
          return {
            quoteId: quoteId,
            productId: item.productId,
            productName: item.productName,
            description: item.description,
            unit: item.unit,
            quantity: item.quantity,
            unitPrice: item.unitPrice,
            totalPrice: itemTotal,
            fck: item.fck,
            slump: item.slump,
            stoneSize: item.stoneSize
          }
        })

        if (itemsToInsert.length > 0) {
          await tx.insert(quoteItems).values(itemsToInsert)
        }
      }

      const total = subtotal - discount

      // Update Quote Header
      await tx
        .update(quotes)
        .set({
          ...quoteData,
          subtotal,
          discount,
          total,
          validUntil: quoteData.validUntil
            ? new Date(quoteData.validUntil)
            : undefined,
          updatedAt: new Date()
        })
        .where(eq(quotes.id, quoteId))
    })

    // Return full object
    const fullQuote = await db.query.quotes.findFirst({
      where: eq(quotes.id, quoteId),
      with: { items: true, seller: true }
    })

    // Notification trigger — only when status changes to approved or rejected
    if (
      quoteData.status
      && quoteData.status !== existing.status
      && (quoteData.status === 'approved' || quoteData.status === 'rejected')
    ) {
      const statusLabel
        = quoteData.status === 'approved' ? 'aprovado' : 'rejeitado'
      await createNotification({
        companyId: existing.companyId,
        type: 'quote_updated',
        title: `Orçamento ${statusLabel}`,
        body: `${existing.customerName} — status atualizado para ${statusLabel}`,
        link: '/orcamentos',
        icon:
          quoteData.status === 'approved'
            ? 'i-heroicons-check-circle'
            : 'i-heroicons-x-circle'
      })
    }

    return { quote: fullQuote }
  } catch (e: unknown) {
    if ((e as { statusCode?: number }).statusCode) throw e
    console.error('Database Error:', e)
    throw createError({
      statusCode: 500,
      statusMessage: 'Internal Server Error',
      data: { message: e instanceof Error ? e.message : 'Unknown error' }
    })
  }
})
